    <script>





        const questionTextElement = document.getElementById('question-text');
        const questionTopicElement = document.getElementById('question-topic');
        const optionsContainer = document.getElementById('options-container');
        const feedbackElement = document.getElementById('feedback');
        const fileFeedbackElement = document.getElementById('file-feedback');
        const nextButton = document.getElementById('next-btn');
        const prevButton = document.getElementById('prev-btn');
        const quitQuizButton = document.getElementById('quit-quiz-btn');
        
        const quizArea = document.getElementById('quiz-area');
        const resultsArea = document.getElementById('results-area');
        const resultsTitle = document.getElementById('results-title');
        const scoreDisplay = document.getElementById('score-display');
        const incorrectQuestionsList = document.getElementById('incorrect-questions-list');
        
        const jsonFileInput = document.getElementById('json-file');
        const fileInputContainer = document.getElementById('file-input-container');
        
        const modeSelectionArea = document.getElementById('mode-selection-area');
        const examModeButton = document.getElementById('exam-mode-btn');
        const practiceModeButton = document.getElementById('practice-mode-btn');

        const topicSelectionAreaPractice = document.getElementById('topic-selection-area-practice');
        const topicSelectPractice = document.getElementById('topic-select-practice');
        const startPracticeTopicQuizButton = document.getElementById('start-practice-topic-quiz-btn');
        const backToModeSelectButton = document.getElementById('back-to-mode-select-btn');
        const restartButton = document.getElementById('restart-btn');

        const progressBar = document.getElementById('progress-bar');

        let allQuestions = [];
        let currentQuizQuestions = [];
        let currentQuestionIndex = 0;
        // userAnswers ora memorizzerà:
        // { indexDomanda: { 
        //      userSelectedIndexInDisplayed: X, 
        //      displayedOptions: [...], 
        //      correctAnswerIndexInDisplayed: Y 
        //   }
        // }
        let userAnswers = {}; 
        const EXAM_MODE_QUESTION_COUNT = 30;

        // ... (tutti gli altri addEventListener iniziali) ...
        restartButton.addEventListener('click', resetAndGoToStart);
        jsonFileInput.addEventListener('change', handleFileLoad);
        examModeButton.addEventListener('click', startExamMode);
        practiceModeButton.addEventListener('click', showPracticeTopicSelection);
        startPracticeTopicQuizButton.addEventListener('click', startPracticeMode);
        backToModeSelectButton.addEventListener('click', () => {
            topicSelectionAreaPractice.style.display = 'none';
            modeSelectionArea.style.display = 'block';
        });

        nextButton.addEventListener('click', navigateNext);
        prevButton.addEventListener('click', navigatePrev);
        quitQuizButton.addEventListener('click', () => {
            if (confirm("Sei sicuro di voler uscire dal quiz? I progressi non salvati andranno persi.")) {
                resetAndShowModeSelection();
            }
        });
        restartButton.addEventListener('click', resetAndGoToStart);

        function resetAndGoToStart() {
            quizArea.style.display = 'none';
            resultsArea.style.display = 'none';
            modeSelectionArea.style.display = 'none';
            topicSelectionAreaPractice.style.display = 'none';
            fileInputContainer.style.display = 'block';
            jsonFileInput.value = '';
            fileFeedbackElement.textContent = '';
            allQuestions = [];
            currentQuizQuestions = [];
            userAnswers = {};
            currentQuestionIndex = 0;
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
        }
        
        function resetAndShowModeSelection() {
            quizArea.style.display = 'none';
            resultsArea.style.display = 'none';
            topicSelectionAreaPractice.style.display = 'none';
            modeSelectionArea.style.display = 'block';
            currentQuizQuestions = [];
            userAnswers = {};
            currentQuestionIndex = 0;
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        allQuestions = JSON.parse(e.target.result);
                        if (Array.isArray(allQuestions) && allQuestions.length > 0) {
                            modeSelectionArea.style.display = 'block';
                            fileInputContainer.style.display = 'none';
                            fileFeedbackElement.textContent = `Caricate ${allQuestions.length} domande. Scegli una modalità.`;
                            populatePracticeTopicSelector();
                        } else {
                            fileFeedbackElement.textContent = 'File JSON non valido o vuoto.';
                        }
                    } catch (error) {
                        fileFeedbackElement.textContent = 'Errore nel parsing del file JSON.';
                        console.error("Errore JSON:", error);
                    }
                };
                reader.readAsText(file);
            }
        }

        function populatePracticeTopicSelector() {
            const topics = [...new Set(allQuestions.map(q => q.topic))].sort();
            topicSelectPractice.innerHTML = '';
            topics.forEach(topic => {
                const option = document.createElement('option');
                option.value = topic;
                option.textContent = topic;
                topicSelectPractice.appendChild(option);
            });
        }

        function shuffleArray(array) {
            let currentIndex = array.length, randomIndex;
            while (currentIndex != 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }
        
        function getExamQuestions() {
            if (allQuestions.length === 0) return [];
            
            let availableQuestions = [...allQuestions];
            shuffleArray(availableQuestions); 

            if (availableQuestions.length <= EXAM_MODE_QUESTION_COUNT) {
                return availableQuestions; 
            }
            
            const questionsByTopic = {};
            allQuestions.forEach(q => {
                if (!questionsByTopic[q.topic]) {
                    questionsByTopic[q.topic] = [];
                }
                questionsByTopic[q.topic].push(q);
            });

            const topics = Object.keys(questionsByTopic);
            let examQuestions = [];
            let questionsPerTopicIdeal = Math.max(1, Math.floor(EXAM_MODE_QUESTION_COUNT / topics.length));
            
            // Prendi un numero base di domande per topic
            topics.forEach(topic => {
                shuffleArray(questionsByTopic[topic]);
                examQuestions.push(...questionsByTopic[topic].slice(0, questionsPerTopicIdeal));
            });

            // Se non bastano, aggiungi altre domande casualmente da quelle non ancora selezionate
            let currentSelectedIds = new Set(examQuestions.map(q => q.question + q.topic)); // Usa una combinazione per ID più univoco
            let allShuffledForFill = [...allQuestions];
            shuffleArray(allShuffledForFill);

            for (const q of allShuffledForFill) {
                if (examQuestions.length >= EXAM_MODE_QUESTION_COUNT) break;
                if (!currentSelectedIds.has(q.question + q.topic)) {
                    examQuestions.push(q);
                    currentSelectedIds.add(q.question + q.topic);
                }
            }
            
            shuffleArray(examQuestions); // Mescola il set finale
            return examQuestions.slice(0, EXAM_MODE_QUESTION_COUNT);
        }

        function startExamMode() {
            currentQuizQuestions = getExamQuestions();
            if (currentQuizQuestions.length === 0) {
                fileFeedbackElement.textContent = 'Non ci sono abbastanza domande per la modalità esame o file non caricato.';
                return;
            }
            commonQuizStartSetup("Modalità Esame");
        }

        function showPracticeTopicSelection() {
            modeSelectionArea.style.display = 'none';
            topicSelectionAreaPractice.style.display = 'block';
        }

        function startPracticeMode() {
            const selectedTopic = topicSelectPractice.value;
            currentQuizQuestions = allQuestions.filter(q => q.topic === selectedTopic);
            if (currentQuizQuestions.length === 0) {
                alert('Nessuna domanda trovata per questo argomento.');
                return;
            }
            shuffleArray(currentQuizQuestions); // Mescola le domande dell'argomento
            commonQuizStartSetup(`Pratica: ${selectedTopic}`);
        }

        function commonQuizStartSetup(quizTitle) {
            currentQuestionIndex = 0;
            userAnswers = {};
            modeSelectionArea.style.display = 'none';
            topicSelectionAreaPractice.style.display = 'none';
            quizArea.style.display = 'block';
            resultsArea.style.display = 'none';
            feedbackElement.textContent = '';
            resultsTitle.textContent = quizTitle;
            loadQuestion();
            updateNavigationButtons();
            updateProgressBar();
        }
        
        function loadQuestion() {
            const questionData = currentQuizQuestions[currentQuestionIndex];
            questionTopicElement.textContent = `Argomento: ${questionData.topic} (Domanda ${currentQuestionIndex + 1} di ${currentQuizQuestions.length})`;
            questionTextElement.textContent = questionData.question;
            optionsContainer.innerHTML = '';
            feedbackElement.textContent = '';

            let displayedOptions;
            let correctAnswerIndexInDisplayed;
            let userSelectedIndexInDisplayed = -1;

            if (userAnswers.hasOwnProperty(currentQuestionIndex)) {
                // Se la domanda è già stata risposta (es. navigando indietro), usa le opzioni come erano state mostrate
                const answerData = userAnswers[currentQuestionIndex];
                displayedOptions = answerData.displayedOptions;
                correctAnswerIndexInDisplayed = answerData.correctAnswerIndexInDisplayed;
                userSelectedIndexInDisplayed = answerData.userSelectedIndexInDisplayed;
            } else {
                // Altrimenti, mescola le opzioni per la prima visualizzazione
                const originalOptions = [...questionData.options]; // Copia per non modificare l'originale
                const originalCorrectAnswerText = originalOptions[questionData.answer];
                
                displayedOptions = shuffleArray(originalOptions); // Mescola la copia
                correctAnswerIndexInDisplayed = displayedOptions.indexOf(originalCorrectAnswerText);
            }

            displayedOptions.forEach((optionText, indexInDisplayed) => {
                const button = document.createElement('button');
                button.textContent = optionText;
                
                if (userAnswers.hasOwnProperty(currentQuestionIndex)) {
                    button.disabled = true;
                    if (indexInDisplayed === correctAnswerIndexInDisplayed) {
                        button.classList.add('correct');
                    } else if (indexInDisplayed === userSelectedIndexInDisplayed) {
                        button.classList.add('incorrect');
                    }
                    if (indexInDisplayed === userSelectedIndexInDisplayed) {
                         button.classList.add('selected');
                    }
                } else {
                    button.addEventListener('click', () => selectAnswer(indexInDisplayed, correctAnswerIndexInDisplayed, displayedOptions));
                }
                optionsContainer.appendChild(button);
            });
            updateNavigationButtons();
        }

        function selectAnswer(selectedIndexInDisplayed, correctAnswerIndexInDisplayedFromLoad, currentDisplayedOptions) {
            if (userAnswers.hasOwnProperty(currentQuestionIndex)) return; 

            userAnswers[currentQuestionIndex] = {
                userSelectedIndexInDisplayed: selectedIndexInDisplayed,
                displayedOptions: currentDisplayedOptions, // Salva le opzioni come sono state mostrate
                correctAnswerIndexInDisplayed: correctAnswerIndexInDisplayedFromLoad // Salva l'indice corretto relativo alle opzioni mostrate
            };
            
            const buttons = optionsContainer.getElementsByTagName('button');
            let isCorrect = selectedIndexInDisplayed === correctAnswerIndexInDisplayedFromLoad;

            if (isCorrect) {
                feedbackElement.textContent = 'Corretto!';
                feedbackElement.style.color = 'var(--success-color)';
            } else {
                feedbackElement.textContent = `Sbagliato! La risposta corretta era: ${currentDisplayedOptions[correctAnswerIndexInDisplayedFromLoad]}`;
                feedbackElement.style.color = 'var(--danger-color)';
                buttons[selectedIndexInDisplayed].classList.add('incorrect');
            }
            buttons[correctAnswerIndexInDisplayedFromLoad].classList.add('correct');

            for (let button of buttons) {
                button.disabled = true;
            }
            updateNavigationButtons();
            updateProgressBar();
        }

        function navigateNext() {
             if (currentQuestionIndex < currentQuizQuestions.length - 1) {
                currentQuestionIndex++;
                loadQuestion();
            } else {
                // Assicurati che l'ultima domanda sia stata risposta prima di mostrare i risultati
                if (userAnswers.hasOwnProperty(currentQuestionIndex) || currentQuizQuestions.length === 0) {
                    showResults();
                } else {
                    // Potresti voler aggiungere un feedback se l'utente prova ad andare ai risultati senza rispondere
                    // alert("Devi rispondere alla domanda corrente prima di vedere i risultati.");
                }
            }
        }

        function navigatePrev() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                loadQuestion();
            }
        }

        function updateNavigationButtons() {
            prevButton.style.display = currentQuestionIndex > 0 ? 'inline-block' : 'none';
            
            const isLastQuestion = currentQuestionIndex === currentQuizQuestions.length - 1;
            const answeredCurrent = userAnswers.hasOwnProperty(currentQuestionIndex);

            if (isLastQuestion) {
                nextButton.textContent = answeredCurrent ? 'Mostra Risultati' : 'Successiva';
                // Nascondi "Mostra Risultati" se l'ultima domanda non è stata ancora risposta
                nextButton.style.display = answeredCurrent ? 'inline-block' : 'none'; 
            } else {
                nextButton.textContent = 'Successiva';
                // Il pulsante Successiva è sempre visibile tranne che all'ultima domanda non risposta
                nextButton.style.display = 'inline-block'; 
            }
        }
        
        function updateProgressBar() {
            const answeredCount = Object.keys(userAnswers).length;
            const totalQuestionsInQuiz = currentQuizQuestions.length;
            const progress = totalQuestionsInQuiz > 0 ? (answeredCount / totalQuestionsInQuiz) * 100 : 0;
            progressBar.style.width = `${progress}%`;
            progressBar.textContent = totalQuestionsInQuiz > 0 ? `${Math.round(progress)}% (${answeredCount}/${totalQuestionsInQuiz})` : '0%';
        }

        function showResults() {
            quizArea.style.display = 'none';
            resultsArea.style.display = 'block';
            
            let score = 0;
            const incorrectAnswersDetails = [];

            for (let i = 0; i < currentQuizQuestions.length; i++) {
                const questionData = currentQuizQuestions[i]; 
                
                if (!userAnswers.hasOwnProperty(i) && currentQuizQuestions.length > 0) { 
                    incorrectAnswersDetails.push({
                        question: questionData.question,
                        topic: questionData.topic,
                        yourAnswer: "<i>Non risposto</i>",
                        correctAnswer: questionData.options[questionData.answer] // Testo originale della risposta corretta
                    });
                    continue; 
                }

                const userAnswerData = userAnswers[i];
                // Ora usiamo displayedOptions e correctAnswerIndexInDisplayed per ottenere i testi corretti
                const userSelectedOptionText = userAnswerData.displayedOptions[userAnswerData.userSelectedIndexInDisplayed];
                const correctOptionTextInDisplayed = userAnswerData.displayedOptions[userAnswerData.correctAnswerIndexInDisplayed];

                if (userAnswerData.userSelectedIndexInDisplayed === userAnswerData.correctAnswerIndexInDisplayed) {
                    score++;
                } else {
                    incorrectAnswersDetails.push({
                        question: questionData.question,
                        topic: questionData.topic,
                        yourAnswer: userSelectedOptionText,
                        correctAnswer: correctOptionTextInDisplayed
                    });
                }
            }
            
            scoreDisplay.textContent = `Punteggio Finale: ${score} su ${currentQuizQuestions.length}`;
            
            incorrectQuestionsList.innerHTML = '';
            if (incorrectAnswersDetails.length > 0) {
                incorrectAnswersDetails.forEach(item => {
                    const li = document.createElement('li');
                    li.innerHTML = `<strong>Domanda (${item.topic}):</strong> ${item.question}<br>
                                    <em>Tua risposta:</em> ${item.yourAnswer}<br>
                                    <em>Risposta corretta:</em> ${item.correctAnswer}`;
                    incorrectQuestionsList.appendChild(li);
                });
            } else {
                if (currentQuizQuestions.length > 0) {
                    incorrectQuestionsList.innerHTML = '<li>Nessuna domanda sbagliata! Complimenti!</li>';
                } else {
                     incorrectQuestionsList.innerHTML = '<li>Nessuna domanda presente in questo quiz.</li>';
                }
            }
        }
    </script>
</body>
</html>